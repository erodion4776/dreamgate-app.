// netlify/functions/interpret.js
const { createClient } = require('@supabase/supabase-js');
const OpenAI = require('openai');


const supabaseUrl = process.env.SUPABASE_URL;
const supabaseKey = process.env.SUPABASE_SERVICE_KEY;
const openaiKey = process.env.OPENAI_API_KEY;


const supabase = createClient(supabaseUrl, supabaseKey);
const openai = new OpenAI({ apiKey: openaiKey });


const DREAM_INTERPRETER_PROMPT = `You are a compassionate Dream Interpreter. Your role is to interpret dreams in a warm, symbolic, and emotionally insightful way. Do NOT give medical, legal or financial advice and avoid religious dogma. Always be empathetic and personal.


When given a dream, follow this response structure:
1) Acknowledge: one warm sentence (e.g., "That sounds powerful — thank you for sharing.").
2) Summary: 1–2 sentence recap of the dream.
3) Symbol explanation: list 3 main symbols (objects/people/actions) and short symbolic meanings.
4) Emotional insight: 2–4 sentences connecting the dream to feelings, stressors, or life situations.
5) Practical guidance: 1–2 concrete suggestions (journaling prompt, affirmation, small action).
6) Follow-up question: one open question to invite reflection (e.g., "How did you feel when...").


Tone: warm, gentle, human. Encourage reflection, not prescriptions.


If user asks about anything not related to dreams, reply:
"I'm here only to help you understand dreams. Please tell me a dream you'd like me to interpret."`;


exports.handler = async (event, context) => {
  // Only allow POST
  if (event.httpMethod !== 'POST') {
    return {
      statusCode: 405,
      body: JSON.stringify({ error: 'Method not allowed' })
    };
  }


  try {
    // Get the authorization header
    const token = event.headers.authorization?.replace('Bearer ', '');
    
    if (!token) {
      return {
        statusCode: 401,
        body: JSON.stringify({ error: 'No authorization token provided' })
      };
    }


    // Verify the user with Supabase
    const { data: { user }, error: authError } = await supabase.auth.getUser(token);
    
    if (authError || !user) {
      console.error('Auth error:', authError);
      return {
        statusCode: 401,
        body: JSON.stringify({ error: 'Invalid or expired token' })
      };
    }


    // Parse the request body
    const { dreamText } = JSON.parse(event.body || '{}');
    
    if (!dreamText) {
      return {
        statusCode: 400,
        body: JSON.stringify({ error: 'Dream text is required' })
      };
    }


    // Check user's interpretation count for the month
    const startOfMonth = new Date();
    startOfMonth.setDate(1);
    startOfMonth.setHours(0, 0, 0, 0);


    const { data: dreams, error: countError } = await supabase
      .from('dreams')
      .select('id')
      .eq('user_id', user.id)
      .gte('created_at', startOfMonth.toISOString());


    if (countError) {
      console.error('Count error:', countError);
      // Don't fail the request, just log the error
    }


    // Check if user has reached free limit (3 per month)
    const dreamCount = dreams?.length || 0;
    
    // Check subscription status (you'll need to implement this based on your subscription model)
    const { data: subscription, error: subError } = await supabase
      .from('subscriptions')
      .select('status')
      .eq('user_id', user.id)
      .single();


    const isSubscribed = subscription?.status === 'active';


    if (!isSubscribed && dreamCount >= 3) {
      return {
        statusCode: 402,
        body: JSON.stringify({ 
          error: 'Free interpretation limit reached. Please subscribe for unlimited access.',
          limit_reached: true 
        })
      };
    }


    // Generate interpretation using OpenAI with the specific prompt
    let interpretation;
    try {
      const completion = await openai.chat.completions.create({
        model: "gpt-3.5-turbo",
        messages: [
          {
            role: "system",
            content: DREAM_INTERPRETER_PROMPT
          },
          {
            role: "user",
            content: dreamText
          }
        ],
        max_tokens: 600, // Increased for structured response
        temperature: 0.7
      });


      interpretation = completion.choices?.[0]?.message?.content || 
                      "I couldn't generate an interpretation at this moment. Please try again.";
      
    } catch (openaiError) {
      console.error('OpenAI error:', openaiError);
      return {
        statusCode: 503,
        body: JSON.stringify({ 
          error: 'AI service temporarily unavailable. Please try again later.' 
        })
      };
    }


    // Generate a title for the dream (first 50 chars or first sentence)
    const title = dreamText.length > 50 
      ? dreamText.substring(0, 47) + '...' 
      : dreamText.split('.')[0] || dreamText;


    // Save the dream to database
    const { data: dream, error: dreamError } = await supabase
      .from('dreams')
      .insert({
        user_id: user.id,
        title: title,
        content: dreamText,
        interpretation: interpretation
      })
      .select()
      .single();


    if (dreamError) {
      console.error('Dream save error:', dreamError);
      // Still return the interpretation even if saving fails
      return {
        statusCode: 200,
        body: JSON.stringify({
          reply: interpretation,
          warning: 'Dream interpretation generated but not saved.'
        })
      };
    }


    // Save messages to the messages table
    if (dream && dream.id) {
      // Save user message
      await supabase
        .from('messages')
        .insert({
          dream_id: dream.id,
          sender: 'user',
          content: dreamText
        });


      // Save AI response
      await supabase
        .from('messages')
        .insert({
          dream_id: dream.id,
          sender: 'ai',
          content: interpretation
        });
    }


    // Return the interpretation
    return {
      statusCode: 200,
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        reply: interpretation,
        dream_id: dream?.id,
        interpretations_left: isSubscribed ? 'unlimited' : Math.max(0, 3 - dreamCount - 1)
      })
    };


  } catch (error) {
    console.error('Handler error:', error);
    return {
      statusCode: 500,
      body: JSON.stringify({ 
        error: 'An unexpected error occurred. Please try again.',
        details: process.env.NODE_ENV === 'development' ? error.message : undefined
      })
    };
  }
};