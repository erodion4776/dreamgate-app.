import React, { useState, useEffect, useRef } from 'react';
import { supabase } from '../services/supabase';
import { dreamInterpreterService } from '../services/dreamInterpreterService';
import { dreamService } from '../services/supabase';

function ChatView({
  messages,
  currentDream,
  user,
  interpretationData,
  onNewMessage,
  onNewDream,
  onLimitReached
}) {
  const [input, setInput] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const messagesEndRef = useRef(null);
  const textareaRef = useRef(null);

  useEffect(() => {
    scrollToBottom();
  }, [messages]);

  useEffect(() => {
    // Properly typed event listener for pending dream
    const handlePendingDream = (event) => {
      // Check if event has detail property
      if (event.detail && typeof event.detail === 'string') {
        setInput(event.detail);
        setTimeout(() => handleSubmit(event.detail), 100);
      }
    };
    
    // Add event listener with proper type
    window.addEventListener('submitPendingDream', handlePendingDream);
    
    // Cleanup
    return () => {
      window.removeEventListener('submitPendingDream', handlePendingDream);
    };
  }, []);

  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  };

  const handleSubmit = async (dreamText) => {
    const text = dreamText || input.trim();
    if (!text || !user) return;

    setInput('');
    setIsLoading(true);

    // Add user message (with safe defaults)
    const userMessage = {
      dream_id: currentDream?.id || null,
      sender: 'user',
      content: text,
      created_at: new Date().toISOString()
    };
    onNewMessage(userMessage);

    try {
      const { data: { session } } = await supabase.auth.getSession();
      if (!session) throw new Error('No session');

      const response = await dreamInterpreterService.interpretDream(
        text,
        session.access_token,
        currentDream?.id || null,
        !!currentDream
      );

      // Add AI response
      const aiMessage = {
        dream_id: response.dream_id || currentDream?.id || null,
        sender: 'ai',
        content: response.reply,
        created_at: new Date().toISOString()
      };
      onNewMessage(aiMessage);

      // Create new dream if needed (with all required fields)
      if (response.dream_id && !currentDream) {
        const title = text.length > 50 ? text.substring(0, 47) + '...' : text;
        
        // Create dream with all required fields
        const newDream = {
          id: response.dream_id,
          user_id: user.id,
          title: title,
          content: text,
          interpretation: response.reply,
          created_at: new Date().toISOString()
        };
        
        onNewDream(newDream);
      }

      // Save messages to database
      if (currentDream?.id || response.dream_id) {
        const dreamId = currentDream?.id || response.dream_id;
        
        try {
          await dreamService.addMessage(dreamId, 'user', text);
          await dreamService.addMessage(dreamId, 'ai', response.reply);
        } catch (dbError) {
          console.error('Error saving messages:', dbError);
          // Don't fail the whole operation if saving fails
        }
      }

    } catch (error) {
      console.error('Error:', error);
      
      if (error.message === 'LIMIT_REACHED') {
        onLimitReached();
      } else {
        // Show error message
        const errorMessage = {
          dream_id: currentDream?.id || null,
          sender: 'ai',
          content: 'Sorry, there was an error. Please try again.',
          created_at: new Date().toISOString()
        };
        onNewMessage(errorMessage);
      }
    } finally {
      setIsLoading(false);
    }
  };

  const handleInputChange = (e) => {
    setInput(e.target.value);
    // Auto-resize textarea
    e.target.style.height = 'auto';
    e.target.style.height = Math.min(e.target.scrollHeight, 100) + 'px';
  };

  const formatMessage = (content, sender) => {
    if (sender === 'ai') {
      return (
        <div 
          dangerouslySetInnerHTML={{ 
            __html: dreamInterpreterService.formatAIResponse(content) 
          }} 
        />
      );
    }
    return content;
  };

  return (
    <div className="chat-container">
      <div className="chat-messages">
        {messages.map((message, index) => (
          <div key={index} className={`message ${message.sender}`}>
            <div className="message-bubble">
              {formatMessage(message.content, message.sender)}
            </div>
          </div>
        ))}
        
        {isLoading && (
          <div className="message ai">
            <div className="loading">
              <div className="dot"></div>
              <div className="dot"></div>
              <div className="dot"></div>
            </div>
          </div>
        )}
        
        {currentDream && !isLoading && (
          <div className="continue-notice">
            ðŸ’¬ You can continue this conversation. Ask follow-up questions or share more details!
          </div>
        )}
        
        <div ref={messagesEndRef} />
      </div>

      <div className="input-container">
        <form 
          className="input-form" 
          onSubmit={(e) => {
            e.preventDefault();
            handleSubmit();
          }}
        >
          <textarea
            ref={textareaRef}
            className="dream-input"
            placeholder={currentDream ? "Continue the conversation..." : "Describe your dream..."}
            value={input}
            onChange={handleInputChange}
            rows={1}
            disabled={isLoading}
          />
          <button 
            type="submit" 
            className="send-btn"
            disabled={isLoading || !input.trim()}
          >
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
              <path d="M22 2L11 13M22 2L15 22L11 13L2 9L22 2Z"/>
            </svg>
          </button>
        </form>
      </div>
    </div>
  );
}

export default ChatView;